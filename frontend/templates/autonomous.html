<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autonomous Driving Monitor - ESP32-CAM Car</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1rem;
            opacity: 0.9;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .card-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        /* 스트림 컨테이너 */
        .stream-container {
            position: relative;
            width: 100%;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            min-height: 400px;
            margin-bottom: 20px;  /* 결과 패널과의 간격 */
        }

        #videoStream {
            width: 100%;
            border-radius: 10px;
            display: block;
        }

        .stream-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            font-size: 1.2rem;
        }

        .stream-overlay.show {
            display: flex;
        }

        #retryButton {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
            margin-top: 15px;
        }

        #retryButton:hover {
            background: #764ba2;
            transform: translateY(-2px);
        }

        /* 제어 패널 */
        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .btn {
            padding: 12px 20px;
            font-size: 0.95rem;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }

        .btn-start {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .btn-start:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(56, 239, 125, 0.4);
        }

        .btn-stop {
            background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);
        }

        .btn-stop:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(238, 9, 121, 0.4);
        }

        .btn-analyze {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .btn-analyze:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-analyze.analyzing {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            cursor: wait;
        }
        
        .analysis-timer {
            margin-top: 10px;
            text-align: center;
            color: #667eea;
            font-weight: bold;
            font-size: 0.9rem;
            animation: pulse 1s infinite;
        }
        
        .analysis-result {
            margin-top: 15px;
            padding: 10px;  /* 패딩 감소 */
            background: rgba(0, 0, 0, 0.85);  /* 배경 더 어둡게 */
            border-radius: 5px;  /* 라운드 감소 */
            border: 1px solid rgba(102, 126, 234, 0.4);
            position: absolute;
            bottom: 10px;  /* 위치 조정 */
            left: 10px;
            right: 10px;
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease-out;
            z-index: 10;
            font-family: 'Courier New', monospace;  /* 고정폭 폰트 */
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .result-item {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-label {
            color: #ffffff;
            font-size: 0.7rem;  /* 폰트 크기 감소 */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            font-family: 'Courier New', monospace;  /* 고정폭 폰트 */
            text-transform: uppercase;  /* 대문자로 표시 */
        }
        
        .result-value {
            font-weight: bold;
            color: #ffffff;
            font-size: 0.8rem;  /* 폰트 크기 감소 */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            font-family: 'Courier New', monospace;  /* 고정폭 폰트 */
        }
        
        .result-value.center {
            color: #00ff00;  /* 더 밝은 녹색 */
        }
        
        .result-value.left {
            color: #ff9900;  /* 더 밝은 주황색 */
        }
        
        .result-value.right {
            color: #ff66ff;  /* 더 밝은 핑크색 */
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        @keyframes slideIn {
            from { transform: translateY(-10px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* 상태 표시 */
        .status-box {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .status-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .status-label {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 5px;
        }

        .status-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
        }

        .status-running {
            color: #38ef7d;
        }

        .status-stopped {
            color: #ff6a00;
        }

        /* 히스토그램 */
        .histogram {
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            height: 150px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .histogram-bar {
            flex: 1;
            margin: 0 10px;
            background: linear-gradient(to top, #667eea, #764ba2);
            border-radius: 5px 5px 0 0;
            transition: height 0.3s;
            position: relative;
            min-height: 5px;
        }

        .histogram-bar.left {
            background: linear-gradient(to top, #ee0979, #ff6a00);
        }

        .histogram-bar.center {
            background: linear-gradient(to top, #11998e, #38ef7d);
        }

        .histogram-bar.right {
            background: linear-gradient(to top, #667eea, #764ba2);
        }

        .histogram-label {
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
            color: #333;
        }

        .histogram-value {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.9rem;
            font-weight: bold;
            color: #333;
        }

        /* 로그 */
        .log-box {
            background: #1e1e1e;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            padding: 15px;
            border-radius: 10px;
            height: 200px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-entry.error {
            color: #ff6a00;
        }

        .log-entry.success {
            color: #38ef7d;
        }

        /* 통계 */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #667eea;
        }

        /* 반응형 */
        @media (max-width: 1024px) {
            .dashboard {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .status-box {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>🚗 Autonomous Driving Monitor</h1>
            <p>ESP32-CAM Lane Tracking System</p>
        </div>

        <!-- 대시보드 -->
        <div class="dashboard">
            <!-- Left: Video Stream -->
            <div class="card">
                <div class="card-title">📹 Live Stream</div>
            <div class="stream-container">
                <img id="videoStream" src="" alt="Video Stream">
                <div class="stream-overlay" id="streamOverlay">
                    <div>
                        <p id="streamStatus">Connecting to camera...</p>
                        <button class="btn btn-secondary" onclick="retryStream()" style="margin-top: 15px; display: none;" id="retryButton">
                            🔄 Retry
                        </button>
                    </div>
                </div>
                <!-- 분석 결과를 비디오 위에 오버레이 -->
                <div id="analysisResult" class="analysis-result" style="display: none;">
                    <div class="result-item">
                        <span class="result-label">DIRECTION:</span>
                        <span class="result-value" id="resultCommand">-</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">STATE:</span>
                        <span class="result-value" id="resultState">-</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">CONFIDENCE:</span>
                        <span class="result-value" id="resultConfidence">-</span>
                    </div>
                </div>
            </div>
                
                <!-- Histogram -->
                <div style="margin-top: 20px;">
                    <strong>Lane Pixel Distribution (Histogram)</strong>
                    <div class="histogram">
                        <div style="flex: 1; text-align: center;">
                            <div class="histogram-bar left" id="histLeft" style="height: 0%;">
                                <span class="histogram-value" id="histLeftValue">0</span>
                            </div>
                            <div class="histogram-label">Left</div>
                        </div>
                        <div style="flex: 1; text-align: center;">
                            <div class="histogram-bar center" id="histCenter" style="height: 0%;">
                                <span class="histogram-value" id="histCenterValue">0</span>
                            </div>
                            <div class="histogram-label">Center</div>
                        </div>
                        <div style="flex: 1; text-align: center;">
                            <div class="histogram-bar right" id="histRight" style="height: 0%;">
                                <span class="histogram-value" id="histRightValue">0</span>
                            </div>
                            <div class="histogram-label">Right</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right: Control Panel -->
            <div class="card">
                <div class="card-title">🎮 Control</div>
                <div class="control-panel">
                    <button class="btn btn-start" id="btnStart" onclick="startAutonomous()">
                        ▶️ Start Autonomous
                    </button>
                    <button class="btn btn-stop" id="btnStop" onclick="stopAutonomous()" disabled>
                        ⏹️ Stop Autonomous
                    </button>
                    <button class="btn btn-analyze" id="btnAnalyze" onclick="analyzeSingleFrame()">
                        🔍 Analyze Single Frame
                    </button>
                    <div id="analysisTimer" class="analysis-timer" style="display: none;">
                        Analysis display: <span id="analysisCountdown">5</span>s
                    </div>
                    <div id="analysisResult" class="analysis-result" style="display: none;">
                        <div class="result-item">
                            <span class="result-label">Direction:</span>
                            <span class="result-value" id="resultCommand">-</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">State:</span>
                            <span class="result-value" id="resultState">-</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">Confidence:</span>
                            <span class="result-value" id="resultConfidence">-</span>
                        </div>
                    </div>
                </div>

                <!-- Status Display -->
                <div class="status-box">
                    <div class="status-item">
                        <div class="status-label">Status</div>
                        <div class="status-value status-stopped" id="statusRunning">Stopped</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Command</div>
                        <div class="status-value" id="statusCommand">-</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">State</div>
                        <div class="status-value" id="statusState">-</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Confidence</div>
                        <div class="status-value" id="statusConfidence">-</div>
                    </div>
                </div>

                <!-- Statistics -->
                <div style="margin-top: 30px;">
                    <strong>Statistics</strong>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Frames</div>
                            <div class="stat-value" id="statFrames">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Commands</div>
                            <div class="stat-value" id="statCommands">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Errors</div>
                            <div class="stat-value" id="statErrors">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Elapsed</div>
                            <div class="stat-value" id="statTime">0s</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">FPS</div>
                            <div class="stat-value" id="statFPS">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Frame Time</div>
                            <div class="stat-value" id="statFrameTime">0ms</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Log -->
        <div class="card">
            <div class="card-title">📜 System Log</div>
            <div class="log-box" id="logBox">
                <div class="log-entry">System ready...</div>
            </div>
        </div>
    </div>

    <script>
        // 전역 변수
        const ESP32_IP = "{{ esp32_ip }}";
        let statusInterval = null;
        let streamRetryCount = 0;
        const MAX_RETRY = 3;
        const RETRY_INTERVAL = 5000; // 5초

        // 스트림 상태 표시
        function showStreamStatus(message, showRetry = false) {
            const overlay = document.getElementById('streamOverlay');
            const status = document.getElementById('streamStatus');
            const retryBtn = document.getElementById('retryButton');
            
            status.textContent = message;
            retryBtn.style.display = showRetry ? 'block' : 'none';
            overlay.classList.add('show');
        }

        function hideStreamStatus() {
            const overlay = document.getElementById('streamOverlay');
            overlay.classList.remove('show');
        }

        // 카메라 연결 확인
        async function checkCamera() {
            try {
                const response = await fetch('/api/autonomous/check_camera');
                const data = await response.json();
                
                if (!data.success) {
                    showStreamStatus(`Camera connection failed: ${data.error}`, true);
                    addLog(`✗ Camera connection failed: ${data.error}`, 'error');
                    return false;
                }
                addLog('✓ Camera connected', 'success');
                return true;
            } catch (e) {
                showStreamStatus(`Camera check error: ${e.message}`, true);
                addLog(`✗ Camera check error: ${e.message}`, 'error');
                return false;
            }
        }

        // 스트림 초기화 (폴링 방식)
        let streamInterval = null;
        let streamFrameCount = 0;
        
        async function initStream() {
            showStreamStatus('Checking camera connection...');
            addLog('Checking camera connection...', 'info');
            
            if (await checkCamera()) {
                addLog('✓ Camera connection verified', 'success');
                addLog('Starting stream using ESP32-CAM /capture endpoint...', 'info');
                startStreamPolling();
            }
        }
        
        // 스트림 폴링 시작 (only when autonomous is not running)
        let autonomousRunning = false;
        
        function startStreamPolling() {
            const videoStream = document.getElementById('videoStream');
            const TARGET_FPS = 5; // 5fps로 제한
            const FRAME_INTERVAL = 1000 / TARGET_FPS; // 200ms
            
            // 기존 폴링 중지
            if (streamInterval) {
                clearInterval(streamInterval);
            }
            
            // 첫 프레임 로드
            loadFrame();
            
            // 주기적으로 프레임 로드 (only when autonomous is not running)
            streamInterval = setInterval(() => {
                if (!autonomousRunning) {
                    loadFrame();
                }
            }, FRAME_INTERVAL);
            
            function loadFrame() {
                // 타임스탬프를 추가하여 캐시 방지
                const timestamp = new Date().getTime();
                const captureUrl = `http://${ESP32_IP}/capture?t=${timestamp}`;
                
                const img = new Image();
                img.onload = function() {
                    videoStream.src = this.src;
                    streamFrameCount++;
                    
                    // 첫 프레임 로드 시
                    if (streamFrameCount === 1) {
                        hideStreamStatus();
                        addLog('✓ Stream connected (/capture polling)', 'success');
                    }
                    
                    // 10 프레임마다 로그
                    if (streamFrameCount % 50 === 0) {
                        addLog(`Stream running (frames: ${streamFrameCount})`, 'info');
                    }
                };
                
                img.onerror = function() {
                    if (streamFrameCount === 0) {
                        // 첫 프레임 로드 실패
                        handleStreamError();
                    }
                    // 이후 프레임은 에러 무시 (네트워크 일시적 문제)
                };
                
                img.src = captureUrl;
            }
        }
        
        // 스트림 폴링 중지
        function stopStreamPolling() {
            if (streamInterval) {
                clearInterval(streamInterval);
                streamInterval = null;
                addLog('Stream polling stopped', 'info');
            }
        }

        // 스트림 에러 처리
        function handleStreamError() {
            showStreamStatus('Stream connection failed', true);
            addLog('✗ Stream connection failed', 'error');
        }

        // 스트림 재시도
        function retryStream() {
            if (streamRetryCount >= MAX_RETRY) {
                showStreamStatus('Max retries exceeded. Please refresh the page.', true);
                addLog('✗ Max retries exceeded', 'error');
                return;
            }

            streamRetryCount++;
            streamFrameCount = 0;
            showStreamStatus('Reconnecting stream...');
            addLog('Attempting stream reconnection...', 'info');
            
            startStreamPolling();
        }

        // 자율주행 시작
        async function startAutonomous() {
            try {
                addLog('🚀 Starting autonomous driving...', 'info');
                
                // Disable button immediately
                document.getElementById('btnStart').disabled = true;
                document.getElementById('statusRunning').textContent = 'Starting...';
                
                const response = await fetch('/api/autonomous/start', {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                const data = await response.json();

                if (data.success) {
                    addLog('✓ Autonomous driving started - Commands will be sent to ESP32', 'success');
                    document.getElementById('btnStart').disabled = true;
                    document.getElementById('btnStop').disabled = false;
                    document.getElementById('statusRunning').textContent = 'Running';
                    document.getElementById('statusRunning').className = 'status-value status-running';
                    
                    // Mark autonomous as running
                    autonomousRunning = true;
                    
                    // Start status polling
                    startStatusPolling();
                    
                    // Update UI with initial processed image if available
                    if (data.initial_frame && data.initial_frame.processed_image) {
                        document.getElementById('videoStream').src = 'data:image/jpeg;base64,' + data.initial_frame.processed_image;
                        
                        // Update histogram
                        if (data.initial_frame.histogram) {
                            updateHistogram(data.initial_frame.histogram);
                        }
                        
                        // Update status
                        document.getElementById('statusCommand').textContent = data.initial_frame.command || '-';
                        document.getElementById('statusState').textContent = data.initial_frame.state || '-';
                        document.getElementById('statusConfidence').textContent = 
                            data.initial_frame.confidence ? (data.initial_frame.confidence * 100).toFixed(1) + '%' : '-';
                    }
                } else {
                    addLog('✗ Start failed: ' + (data.error || data.message), 'error');
                    document.getElementById('btnStart').disabled = false;
                    document.getElementById('statusRunning').textContent = 'Error';
                }
            } catch (error) {
                addLog('✗ Error starting autonomous: ' + error.message, 'error');
                document.getElementById('btnStart').disabled = false;
                document.getElementById('statusRunning').textContent = 'Error';
                document.getElementById('statusRunning').className = 'status-value status-stopped';
            }
        }

        // 자율주행 중지
        async function stopAutonomous() {
            try {
                addLog('🛑 Stopping autonomous driving...', 'info');
                
                // Immediately update UI to show stopping
                document.getElementById('statusRunning').textContent = 'Stopping...';
                document.getElementById('statusRunning').className = 'status-value status-stopped';
                document.getElementById('btnStop').disabled = true;
                
                const response = await fetch('/api/autonomous/stop', {
                    method: 'POST'
                });
                const data = await response.json();

                if (data.success) {
                    addLog('✓ Autonomous driving stopped - Motor STOP command sent', 'success');
                    document.getElementById('btnStart').disabled = false;
                    document.getElementById('btnStop').disabled = true;
                    
                    // Mark autonomous as not running
                    autonomousRunning = false;
                    
                    // Update status immediately
                    document.getElementById('statusRunning').textContent = 'Stopped';
                    document.getElementById('statusCommand').textContent = 'STOP';
                    document.getElementById('statusCommand').style.color = '#ee0979';
                    
                    // 상태 폴링 중지
                    stopStatusPolling();
                    
                    // 통계 업데이트
                    if (data.stats) {
                        updateStats(data.stats);
                    }
                    
                    // Resume stream polling for monitoring
                    if (!streamInterval) {
                        startStreamPolling();
                    }
                } else {
                    addLog('✗ Stop failed: ' + data.message, 'error');
                    document.getElementById('statusRunning').textContent = 'Error';
                    document.getElementById('btnStop').disabled = false;
                }
            } catch (error) {
                addLog('✗ Error: ' + error.message, 'error');
                document.getElementById('statusRunning').textContent = 'Error';
                document.getElementById('btnStop').disabled = false;
            }
        }

        let analysisTimer = null;  // Timer for analysis display
        let originalStreamSrc = null;  // Store original stream source
        let countdownInterval = null;  // Timer for countdown display
        
        // 단일 프레임 분석
        async function analyzeSingleFrame() {
            try {
                // Clear existing timers if any
                if (analysisTimer) {
                    clearTimeout(analysisTimer);
                    analysisTimer = null;
                }
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
                
                // Update button state
                const btnAnalyze = document.getElementById('btnAnalyze');
                btnAnalyze.classList.add('analyzing');
                btnAnalyze.disabled = true;
                btnAnalyze.textContent = '⏳ Analyzing...';
                
                addLog('🔍 Analyzing single frame...', 'info');
                
                const response = await fetch('/api/autonomous/analyze', {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                const data = await response.json();

                if (data.success) {
                    addLog(`✓ Analysis complete: ${data.command} (confidence: ${(data.confidence * 100).toFixed(1)}%)`, 'success');
                    addLog('Displaying analysis result for 5 seconds...', 'info');
                    
                    // Show countdown timer
                    const timerDiv = document.getElementById('analysisTimer');
                    const countdownSpan = document.getElementById('analysisCountdown');
                    timerDiv.style.display = 'block';
                    let countdown = 5;
                    
                    // Show analysis result
                    const resultDiv = document.getElementById('analysisResult');
                    resultDiv.style.display = 'block';
                    resultDiv.style.animation = 'slideIn 0.3s ease-out';
                    
                    // Update result values with animation
                    const resultCommand = document.getElementById('resultCommand');
                    const resultState = document.getElementById('resultState');
                    const resultConfidence = document.getElementById('resultConfidence');
                    
                    resultCommand.textContent = data.command;
                    resultCommand.className = 'result-value ' + data.command.toLowerCase();
                    resultState.textContent = data.state;
                    resultConfidence.textContent = (data.confidence * 100).toFixed(1) + '%';
                    
                    // Update countdown every second
                    countdownInterval = setInterval(() => {
                        countdown--;
                        countdownSpan.textContent = countdown;
                        if (countdown <= 0) {
                            clearInterval(countdownInterval);
                            countdownInterval = null;
                            timerDiv.style.display = 'none';
                            resultDiv.style.display = 'none';
                        }
                    }, 1000);
                    
                    // Store original stream source if not stored
                    const videoStream = document.getElementById('videoStream');
                    if (!originalStreamSrc) {
                        originalStreamSrc = videoStream.src;
                    }
                    
                    // 결과 표시
                    document.getElementById('statusCommand').textContent = data.command;
                    document.getElementById('statusState').textContent = data.state;
                    document.getElementById('statusConfidence').textContent = (data.confidence * 100).toFixed(1) + '%';
                    
                    // 히스토그램 업데이트
                    updateHistogram(data.histogram);
                    
                    // 이미지 표시 및 결과 패널 표시
                    if (data.image_base64) {
                        // 이미지 표시
                        videoStream.src = 'data:image/jpeg;base64,' + data.image_base64;
                        
                        // 5초 후 모든 것을 원래대로 복구
                        analysisTimer = setTimeout(() => {
                            // 원본 스트림 복구
                            if (originalStreamSrc) {
                                videoStream.src = originalStreamSrc;
                                addLog('Analysis display ended', 'info');
                            }
                            analysisTimer = null;
                            
                            // 버튼 상태 초기화
                            const btnAnalyze = document.getElementById('btnAnalyze');
                            btnAnalyze.classList.remove('analyzing');
                            btnAnalyze.disabled = false;
                            btnAnalyze.textContent = '🔍 Analyze Single Frame';
                            
                            // 타이머와 결과 패널 숨기기
                            document.getElementById('analysisTimer').style.display = 'none';
                            document.getElementById('analysisResult').style.display = 'none';
                            
                            // 원본 스트림 폴링 재시작
                            if (!autonomousRunning) {
                                startStreamPolling();
                            }
                        }, 5000);  // 5초 후 복구
                        
                        // 스트림 폴링 일시 중지 (분석 이미지 유지를 위해)
                        if (streamInterval) {
                            clearInterval(streamInterval);
                        }
                    }
                } else {
                    addLog('✗ Analysis failed: ' + (data.error || 'Unknown error'), 'error');
                    // Reset button
                    const btnAnalyze = document.getElementById('btnAnalyze');
                    btnAnalyze.classList.remove('analyzing');
                    btnAnalyze.disabled = false;
                    btnAnalyze.textContent = '🔍 Analyze Single Frame';
                }
            } catch (error) {
                addLog('✗ Analysis error: ' + error.message, 'error');
                // Reset button
                const btnAnalyze = document.getElementById('btnAnalyze');
                btnAnalyze.classList.remove('analyzing');
                btnAnalyze.disabled = false;
                btnAnalyze.textContent = '🔍 Analyze Single Frame';
            }
        }
        
        // Clean up timers when leaving page
        window.addEventListener('beforeunload', () => {
            if (analysisTimer) {
                clearTimeout(analysisTimer);
            }
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            // Reset UI state
            const btnAnalyze = document.getElementById('btnAnalyze');
            btnAnalyze.classList.remove('analyzing');
            btnAnalyze.disabled = false;
            document.getElementById('analysisTimer').style.display = 'none';
        });

        // 상태 폴링 시작
        function startStatusPolling() {
            console.log('🔄 상태 폴링 시작');
            statusInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/autonomous/status');
                    const data = await response.json();

                    console.log('📊 상태 업데이트:', data);

                    if (data.success) {
                        // Update processed image if available (every 1 second)
                        if (data.latest_image && data.is_running) {
                            const videoStream = document.getElementById('videoStream');
                            videoStream.src = 'data:image/jpeg;base64,' + data.latest_image;
                        }
                        
                        // 상태 업데이트
                        document.getElementById('statusRunning').textContent = data.is_running ? 'Running' : 'Stopped';
                        document.getElementById('statusRunning').className = data.is_running ? 'status-value status-running' : 'status-value status-stopped';
                        
                        if (data.last_command) {
                            document.getElementById('statusCommand').textContent = data.last_command;
                            
                            // 명령에 따라 색상 변경
                            const commandEl = document.getElementById('statusCommand');
                            if (data.last_command === 'LEFT') {
                                commandEl.style.color = '#ff6a00';
                            } else if (data.last_command === 'RIGHT') {
                                commandEl.style.color = '#ff00ff';
                            } else if (data.last_command === 'CENTER') {
                                commandEl.style.color = '#38ef7d';
                            } else if (data.last_command === 'STOP') {
                                commandEl.style.color = '#ee0979';
                            }
                        }
                        
                        if (data.state) {
                            const stateText = {
                                'NORMAL_DRIVING': '일반 주행',
                                'CORNER_DETECTED': '코너 감지',
                                'TURNING': '회전 중'
                            }[data.state] || data.state;
                            document.getElementById('statusState').textContent = stateText;
                        }

                        // 통계 업데이트
                        if (data.stats) {
                            updateStats(data.stats);
                        }

                        // 명령 히스토리에서 최근 히스토그램 가져오기
                        if (data.command_history && data.command_history.length > 0) {
                            const latestCommand = data.command_history[data.command_history.length - 1];
                            if (latestCommand.histogram) {
                                updateHistogram(latestCommand.histogram);
                            }
                        }
                    }
                } catch (error) {
                    console.error('상태 조회 오류:', error);
                }
            }, 1000); // 1초마다
        }

        // 상태 폴링 중지
        function stopStatusPolling() {
            if (statusInterval) {
                clearInterval(statusInterval);
                statusInterval = null;
            }
        }

        // 통계 업데이트
        function updateStats(stats) {
            document.getElementById('statFrames').textContent = stats.frames_processed || 0;
            document.getElementById('statCommands').textContent = stats.commands_sent || 0;
            document.getElementById('statErrors').textContent = stats.errors || 0;
            document.getElementById('statTime').textContent = stats.elapsed_time || '0s';
            document.getElementById('statFPS').textContent = stats.fps || '0';
            
            // Frame time with color coding
            const frameTime = stats.last_frame_time || 0;
            const frameTimeEl = document.getElementById('statFrameTime');
            frameTimeEl.textContent = frameTime + 'ms';
            
            // Color code based on speed
            if (frameTime < 100) {
                frameTimeEl.style.color = '#38ef7d';  // Green - Fast
            } else if (frameTime < 200) {
                frameTimeEl.style.color = '#f39c12';  // Orange - OK
            } else {
                frameTimeEl.style.color = '#ee0979';  // Red - Slow
            }
        }

        // 히스토그램 업데이트
        function updateHistogram(histogram) {
            const maxValue = Math.max(histogram.left, histogram.center, histogram.right, 1);
            
            const leftPercent = (histogram.left / maxValue) * 100;
            const centerPercent = (histogram.center / maxValue) * 100;
            const rightPercent = (histogram.right / maxValue) * 100;

            document.getElementById('histLeft').style.height = leftPercent + '%';
            document.getElementById('histCenter').style.height = centerPercent + '%';
            document.getElementById('histRight').style.height = rightPercent + '%';

            document.getElementById('histLeftValue').textContent = histogram.left;
            document.getElementById('histCenterValue').textContent = histogram.center;
            document.getElementById('histRightValue').textContent = histogram.right;
        }

        // 로그 추가
        function addLog(message, type = 'info') {
            const logBox = document.getElementById('logBox');
            const timestamp = new Date().toLocaleTimeString('ko-KR');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = `[${timestamp}] ${message}`;
            logBox.appendChild(entry);
            logBox.scrollTop = logBox.scrollHeight;

            // 최대 100개 로그만 유지
            while (logBox.children.length > 100) {
                logBox.removeChild(logBox.firstChild);
            }
        }

        // 페이지 로드 시 초기화
        window.addEventListener('load', () => {
            addLog('Autonomous driving monitoring system ready', 'success');
            addLog(`ESP32-CAM IP: ${ESP32_IP}`, 'info');
            addLog('Camera stream: Using /capture polling method', 'info');
            initStream();
        });
        
        // 페이지 언로드 시 정리
        window.addEventListener('beforeunload', () => {
            stopStreamPolling();
            stopStatusPolling();
        });
    </script>
</body>
</html>