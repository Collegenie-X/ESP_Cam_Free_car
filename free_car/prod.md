**ESP32-CAM 자율주행 차선 추적 시스템 설계 문서**

본 문서는 ESP32-CAM에서 촬영한 저품질 이미지를 처리하여 **흰색(직진)과 빨간색(코너)** 차선을 인식하고, **빛 반사 노이즈**를 제거하며, **90도 코너**를 판단하는 전체 시스템을 설명합니다.

---

## 시스템 개요

- **환경**: 검정색 바닥 + 흰색 직선 차선 + 빨간색 코너 차선
- **카메라**: ESP32-CAM (저화질, 저조도)
- **처리**: PC에서 Python + OpenCV
- **주요 문제**:
  1. 어두운 이미지 (저조도)
  2. 빛 반사로 인한 흰색 원형 노이즈
  3. 상단 영역의 다른 도로선 간섭
  4. 90도 코너에서의 방향 판단

---

## 전체 동작 순서 및 구현 방식

전체 시스템은 PC에서 Python과 OpenCV 라이브러리를 사용하여 이미지를 처리하는 것을 기준으로 합니다.

### 1단계: 이미지 수신 및 전처리 (선명도 개선)

* **역할:** ESP32-CAM에서 받은 어둡고 품질이 낮은 원본 이미지를 처리하기 좋게 개선합니다.
* **구현 방식 (CLAHE):**
    * 단순히 밝기만 올리면 빛 반사(노이즈)까지 밝아져서 역효과가 날 수 있습니다.
    * **CLAHE (Contrast Limited Adaptive Histogram Equalization)**라는 기술을 사용합니다.
    * 이 기술은 이미지 전체가 아닌, 작은 영역별로 대비(contrast)를 지능적으로 높여줍니다. 어두운 부분은 밝게, 너무 밝은 부분은 유지하여 전반적인 선명도를 크게 향상시킵니다.

### 2단계: 노이즈 제거 (블러링)

* **역할:** CLAHE로 선명해진 이미지의 자잘한 노이즈를 부드럽게 만들어 다음 단계(색상 검출)의 정확도를 높입니다.
* **구현 방식 (가우시안 블러):**
    * 이미지 전체에 **가우시안 블러(Gaussian Blur)**를 약하게 적용하여 픽셀을 주변과 섞어줍니다.

### 3단계: 관심 영역(ROI) 설정 ⭐ 매우 중요

* **역할:** 
  - 상단 영역의 다른 도로선(교차로, 다른 트랙 등)을 완전히 제거
  - 현재 주행에 필요한 바로 앞 차선에만 집중
  - 처리 속도 향상 (관심 영역만 처리)
  
* **구현 방식 (이중 ROI 전략):**
  
  **A. 기본 주행용 ROI (하단 ROI)**
  ```
  이미지 크기: 320x240 기준
  ROI_BOTTOM = {
      'y_start': 180,  # 하단 1/4 영역 (240의 75%부터)
      'y_end': 240,    # 이미지 끝까지
      'x_start': 0,
      'x_end': 320
  }
  높이: 60픽셀 (이미지 하단 25%)
  ```
  - **가장 가까운 차선만 보임** (다른 도로선 간섭 0%)
  - 일반 직진/곡선 주행에 사용
  
  **B. 코너 감지용 ROI (중앙 ROI) - LookAhead**
  ```
  ROI_CENTER = {
      'y_start': 120,  # 중앙 영역
      'y_end': 180,    # 하단 ROI 직전까지
      'x_start': 0,
      'x_end': 320
  }
  높이: 60픽셀 (이미지 중앙 25%)
  ```
  - 90도 코너 감지 시에만 활성화
  - 좌/우 연결 도로 확인용

* **적용 시점:**
  - 평상시: 하단 ROI만 사용
  - 90도 코너 감지 시: 중앙 ROI로 전환하여 방향 판단

### 4단계: 색상 공간 변환 (HSV)

* **역할:** 조명 변화에 민감한 RGB 대신, 색상 구분에 유리한 HSV 색상 공간으로 이미지를 변환합니다.
* **구현 방식 (BGR2HSV):**
    * `cv2.cvtColor()` 함수를 사용해 BGR 이미지를 HSV 이미지로 변환합니다.

### 5단계: 차선 마스크 생성 (흰색 + 빨간색) ⭐ 핵심

* **역할:** 이미지에서 '차선'에 해당하는 모든 픽셀(흰색 *또는* 빨간색)을 찾아 이진화(0 또는 1)합니다.
  - **1 (흰색)**: 차선 (흰색 or 빨간색)
  - **0 (검은색)**: 도로 바닥

* **구현 방식 (적응형 이중 마스킹):**
  
  **A. 흰색 차선 검출 (직진)**
  ```
  HSV 범위 (조명 변화 고려):
  - 밝은 환경: H(0-180), S(0-30), V(200-255)
  - 어두운 환경: H(0-180), S(0-50), V(150-255)
  
  판단 기준:
  - 채도(S)가 낮음 (색상이 없음 = 흰색/회색)
  - 명도(V)가 높음 (밝음)
  ```
  
  **B. 빨간색 차선 검출 (코너)**
  ```
  HSV 범위 (빨간색은 0도와 180도 근처):
  - 범위1: H(0-10), S(100-255), V(100-255)
  - 범위2: H(170-180), S(100-255), V(100-255)
  
  두 범위를 OR 연산으로 결합
  ```
  
  **C. 마스크 결합 및 이진화**
  ```
  combined_mask = white_mask | red_mask
  
  결과: 
  - 픽셀값 255 (1): 차선
  - 픽셀값 0: 도로 바닥
  ```

* **색상 범위 자동 조정 (선택적 개선):**
  - 초기 프레임에서 밝기 평균값 측정
  - 어두우면 (평균 < 80): V 하한값 낮춤 (150 → 120)
  - 밝으면 (평균 > 150): S 상한값 높임 (30 → 50)

### 6단계: 빛 반사 노이즈 제거 (가장 중요) ⭐⭐⭐

* **역할:** 바닥 빛 반사로 생긴 '흰색 원형' 노이즈를 제거하고, 실제 '선' 형태의 차선만 남깁니다.

* **노이즈 특징 분석:**
  - 형태: **원형** (차선은 선형)
  - 크기: **작음** (50-200 픽셀, 차선은 500+ 픽셀)
  - 종횡비: **1:1 근처** (차선은 5:1 이상)
  - 위치: **불규칙** (차선은 연속적)

* **구현 방식 (3단계 필터링 - 권장):**

  **A. 1차 필터: 형태학적 Opening**
  ```
  목적: 작은 점 노이즈 1차 제거
  
  커널 크기: 3x3 또는 5x5 타원형
  연산: Erode → Dilate
  
  효과:
  - 작은 원형 노이즈 제거 (크기 < 10 픽셀)
  - 차선은 유지 (선 형태라 쉽게 안 사라짐)
  ```

  **B. 2차 필터: 컨투어 면적 + 종횡비 필터링 (핵심)**
  ```
  순서:
  1. findContours()로 모든 흰색 덩어리 찾기
  2. 각 컨투어마다 검사:
     
     a. 면적 필터:
        - 면적 < 100 픽셀 → 제거 (작은 노이즈)
        - 면적 > 50 픽셀 → 다음 단계
     
     b. 종횡비 필터:
        - 종횡비 = width / height
        - 종횡비 > 2.0 → 유지 (가로로 긴 선 = 차선)
        - 종횡비 < 2.0 → 제거 (정사각형/원형 = 노이즈)
     
     c. 방향성 필터 (선택):
        - 차선은 좌→우 또는 상→하 방향성 있음
        - 회전 각도가 불규칙하면 제거
  
  3. 통과한 컨투어만 새 마스크에 그리기
  ```

  **C. 3차 필터: 연결성 검사 (90도 코너용)**
  ```
  목적: 분리된 선분을 하나로 연결 (코너에서 끊어진 차선)
  
  방법:
  - 끝점이 가까운 선분들 (거리 < 30픽셀) 연결
  - 각도가 비슷한 선분끼리만 연결 (±30도)
  ```

* **결과:**
  - 깨끗한 이진 마스크 (차선=1, 나머지=0)
  - 노이즈 제거율: 95% 이상

### 7단계: 조향 판단 (히스토그램 + 데드존) ⭐

* **역할:** 깨끗한 차선 마스크를 기반으로 '좌회전', '직진', '우회전'을 결정합니다.

* **구현 방식 (3분할 히스토그램 + 스마트 판단):**

  **A. 이미지 3분할**
  ```
  ROI 너비: 320픽셀 기준
  - 왼쪽 영역: 0 ~ 106 픽셀
  - 중앙 영역: 107 ~ 213 픽셀  
  - 오른쪽 영역: 214 ~ 320 픽셀
  ```

  **B. 각 영역의 차선 픽셀 수 계산**
  ```
  left_count = sum(mask[:, 0:106] == 255)
  center_count = sum(mask[:, 107:213] == 255)
  right_count = sum(mask[:, 214:320] == 255)
  
  total_count = left_count + center_count + right_count
  ```

  **C. 판단 로직 (데드존 포함)**
  ```
  1. 차선이 거의 없는 경우 (total_count < 200):
     → "STOP" (차선 소실, 비상 정지)
  
  2. 좌-우 차이가 작은 경우 (데드존):
     차이 = |left_count - right_count|
     차이율 = 차이 / total_count
     
     if 차이율 < 0.15 (15% 미만):
        → "CENTER" (직진)
        이유: 좌우 균형 = 중앙 주행 중
  
  3. 좌-우 모두 적은 경우 (중앙에 몰림):
     if left_count < 100 AND right_count < 100:
        → "CENTER" (직진)
        이유: 차선이 중앙에만 있음 = 직진 중
  
  4. 명확한 좌우 편향:
     if left_count > right_count * 1.3:
        → "LEFT" (왼쪽에 차선 많음 = 왼쪽으로 복귀)
     elif right_count > left_count * 1.3:
        → "RIGHT" (오른쪽에 차선 많음 = 오른쪽으로 복귀)
     else:
        → "CENTER" (애매하면 직진 유지)
  ```

  **D. 판단 로직 플로우차트**
  ```
  [차선 픽셀 계산]
         ↓
  [총 픽셀 < 200?] YES → STOP
         ↓ NO
  [좌-우 차이 < 15%?] YES → CENTER
         ↓ NO
  [좌우 모두 < 100?] YES → CENTER
         ↓ NO
  [좌 > 우 * 1.3?] YES → LEFT
         ↓ NO
  [우 > 좌 * 1.3?] YES → RIGHT
         ↓ NO
       CENTER
  ```

* **임계값 튜닝:**
  - 차이율 임계값: 0.15 (민감도 조절)
  - 비율 임계값: 1.3 (명확한 편향만 반응)
  - 최소 픽셀: 200 (차선 소실 감지)

### 8단계: 90도 코너 감지 및 판단 ⭐⭐

* **역할:** 가로로 막힌 차선(T자/ㄱ자 코너)을 만났을 때, 좌/우 중 어디로 갈지 판단합니다.

* **문제 상황:**
  ```
  [현재 상황]           [이미지 하단 ROI에서 보이는 것]
  
      ═══════          ════════════════
      ║                (가로 차선이 화면 가득 차 있음)
      ║ ← 진행 방향
      
  → 좌/우 어디로 갈지 모름!
  ```

* **구현 방식 (2단계 감지 + LookAhead):**

  **A. 1단계: 90도 코너 감지**
  ```
  조건:
  1. 하단 ROI의 차선 픽셀이 비정상적으로 많음
     total_pixels = width × height = 320 × 60 = 19,200
     lane_pixels > 15,000 (전체의 78% 이상)
     
  2. 차선이 가로로 퍼져있음 (세로가 아님)
     - 좌중우 영역 모두에 고르게 분포
     - 편차 < 20%
  
  판단:
  if lane_pixels > total_pixels * 0.78:
      AND (left_count, center_count, right_count 편차 < 20%):
      → "90도 코너 감지!"
  ```

  **B. 2단계: 방향 판단 (LookAhead ROI 활용)**
  ```
  [중앙 ROI 분석]
  
  상황 1: 왼쪽에 연결 도로      상황 2: 오른쪽에 연결 도로
  
    ║                             ║
    ║══════                  ═════╝
    ║                             
    
  중앙 ROI에서:                중앙 ROI에서:
  - 왼쪽 영역 픽셀 많음        - 오른쪽 영역 픽셀 많음
  - 오른쪽 영역 픽셀 없음      - 왼쪽 영역 픽셀 없음
  
  판단 로직:
  center_left = sum(center_roi[:, 0:160] == 255)
  center_right = sum(center_roi[:, 160:320] == 255)
  
  if center_left > center_right * 2.0:
      → "LEFT" (왼쪽에 도로 연결됨)
  elif center_right > center_left * 2.0:
      → "RIGHT" (오른쪽에 도로 연결됨)
  else:
      → "TURN_ASSIST" (애매하면 제자리 회전 모드)
  ```

  **C. 제자리 회전 보조 (TURN_ASSIST 모드)**
  ```
  상황: 중앙 ROI에서도 방향 판단 어려움
  
  동작:
  1. 제자리에서 좌회전 (5도씩)
  2. 매 프레임마다 중앙 ROI 재분석
  3. 연결 도로 발견 시 해당 방향으로 진행
  
  최대 회전: 45도 (그래도 못 찾으면 STOP)
  
  코드 흐름:
  for angle in range(0, 45, 5):
      rotate_left(5도)
      center_roi = capture_center_roi()
      left, right = analyze_roi(center_roi)
      
      if left > right * 2.0:
          return "LEFT"
      elif right > left * 2.0:
          return "RIGHT"
  
  return "STOP"  # 45도 회전해도 못 찾음
  ```

* **상태 머신:**
  ```
  상태1: NORMAL_DRIVING (일반 주행)
    ↓ [90도 감지]
  상태2: CORNER_DETECTED (코너 감지)
    ↓ [LookAhead 분석]
  상태3-A: TURNING_LEFT or TURNING_RIGHT (회전 중)
    or
  상태3-B: TURN_ASSIST (제자리 회전 탐색)
    ↓ [회전 완료]
  상태1: NORMAL_DRIVING (복귀)
  ```

* **추가 최적화:**
  - 90도 코너는 대부분 **빨간색 차선**
  - red_mask 비율이 높으면 코너 가능성 높음
  - 미리 감속하여 안정적인 회전

---

## AI 모델의 역할과 현실적인 대안

사용자께서 '노이즈 제거'를 위해 AI 모델을 언급하셨습니다. 이 역할을 수행하는 AI와, 그보다 현실적인 대안을 비교 설명해 드립니다.

### 1. AI 모델 접근 방식 (Semantic Segmentation)

* **모델:** U-Net, ENet 등 (Semantic Segmentation 모델)
* **역할:** AI가 이미지의 모든 픽셀을 '흰색 차선', '빨간색 차선', '빛 반사(노이즈)', '바닥' 4가지로 완벽하게 '분류(색칠)'해줍니다.
* **구현 방식:**
    1.  **데이터 수집:** ESP32-CAM으로 수백 장의 주행 사진(특히 노이즈가 심한 사진)을 수집합니다.
    2.  **데이터 라벨링 (가장 힘든 작업):** 수집한 모든 사진에 대해 포토샵처럼 '여기는 흰색 선', '여기는 노이즈', '여기는 바닥'이라고 픽셀 단위로 직접 색칠하여 정답지를 만듭니다.
    3.  **모델 학습:** PC에서 U-Net 같은 모델을 이 데이터로 학습시킵니다.
    4.  **실행:** 위의 4~6단계(HSV 변환, 마스킹, 노이즈 제거)가 **이 AI 모델로 대체됩니다.** AI가 노이즈와 차선을 완벽히 구분한 마스크 이미지를 출력하면, 7단계(히스토그램)에서 바로 사용합니다.
* **장점:** 매우 정확하고 조명 변화에 강력합니다.
* **단점:** **데이터 라벨링 작업량이 엄청나게 많고**, 모델 학습에 시간이 걸리며, PC에서 실시간 추론 시 약간의 지연(latency)이 발생할 수 있습니다.

### 2. 현실적인 대안 (추천: 전통적인 CV)

위의 **동작 순서 1~8단계**가 바로 전통적인 컴퓨터 비전(CV) 접근 방식입니다.

* **AI가 필요한가?**
    * **어두운 이미지(선명도):** AI(저조도 개선 모델) 대신 **CLAHE**를 사용하면 됩니다. (1단계)
    * **노이즈(빛 반사):** AI(Segmentation) 대신 **형태학적 변환(Opening)** 또는 **컨투어 면적 필터링**을 사용하면 됩니다. (6단계)

**결론적으로, 먼저 전통적인 CV 방식 (CLAHE + HSV 이중 마스크 + 컨투어 필터링)을 시도해 보시는 것을 강력히 추천합니다.** 이 방식은 구현이 훨씬 빠르고 간단하며, 말씀하신 '흰색 원' 형태의 노이즈를 제거하는 데 매우 효과적입니다. AI 모델은 이 방법이 실패했을 때 고려하는 '최종 병기'로 생각하시는 것이 좋습니다.

---

## 추가 개선 방안 및 고려사항

### 1. 실시간 처리 최적화

* **프레임 스킵:**
  - ESP32-CAM: 최대 30fps 가능하지만 너무 많은 프레임 불필요
  - 권장: 10fps (100ms 간격) - 충분한 반응 속도 + 안정성
  
* **비동기 처리:**
  - 카메라 캡처 스레드 (별도)
  - 이미지 처리 스레드 (별도)
  - 모터 제어 스레드 (별도)
  - 서로 블로킹 없이 동작

### 2. 디버깅 및 시각화

* **중간 결과 출력 (개발 단계):**
  1. 원본 이미지
  2. CLAHE 적용 결과
  3. ROI 추출 결과
  4. HSV 마스크 (흰색/빨간색 각각)
  5. 노이즈 제거 후 최종 마스크
  6. 히스토그램 그래프 (좌/중/우 픽셀 분포)
  7. 판단 결과 (LEFT/CENTER/RIGHT/STOP)

* **실시간 모니터링:**
  - Flask 웹 인터페이스에 각 단계별 이미지 표시
  - 현재 상태 (NORMAL_DRIVING / CORNER_DETECTED 등)
  - 픽셀 카운트 수치 실시간 표시

### 3. 파라미터 자동 튜닝

* **최초 캘리브레이션 모드:**
  - 직선 구간에서 10프레임 수집
  - 흰색/빨간색 HSV 범위 자동 학습
  - 최적의 임계값 자동 계산
  
* **적응형 파라미터:**
  - 조명 변화 감지 시 HSV 범위 자동 조정
  - 노이즈 레벨에 따라 필터 강도 조정

### 4. 안전 장치

* **페일세이프 (Fail-Safe):**
  - 차선 소실 3초 이상: 즉시 정지
  - 판단 불가능 상황 (TURN_ASSIST 실패): 정지 후 수동 개입 대기
  
* **이상 감지:**
  - 급격한 방향 전환 (LEFT ↔ RIGHT 1초 이내): 노이즈 가능성, 직진 유지
  - 차선 픽셀 급감: 카메라 오류 가능성, 속도 감속

### 5. 성능 비교 (예상치)

| 방식 | 정확도 | 처리 속도 | 구현 난이도 | 노이즈 제거 |
|------|--------|-----------|-------------|-------------|
| 기본 HSV만 | 60% | 매우 빠름 (5ms) | 쉬움 | 낮음 |
| HSV + Opening | 75% | 빠름 (10ms) | 쉬움 | 중간 |
| **HSV + 컨투어 필터 (권장)** | **90%** | **보통 (20ms)** | **중간** | **높음** |
| AI Segmentation | 95% | 느림 (100ms+) | 어려움 | 매우 높음 |

### 6. 구현 우선순위

**Phase 1 (필수):**
1. 이미지 수신 및 CLAHE 전처리
2. ROI 설정 (하단만)
3. HSV 이중 마스킹 (흰색 + 빨간색)
4. 기본 히스토그램 판단

**Phase 2 (핵심):**
5. 컨투어 기반 노이즈 제거 (종횡비 + 면적)
6. 데드존 로직 추가
7. 디버깅 시각화

**Phase 3 (고급):**
8. 90도 코너 감지
9. LookAhead ROI 추가
10. TURN_ASSIST 모드

**Phase 4 (최적화):**
11. 파라미터 자동 튜닝
12. 성능 최적화 (멀티스레딩)
13. 안전 장치 추가

---

## 기술 스택

### Python 라이브러리
- `opencv-python`: 이미지 처리 (CLAHE, HSV, 컨투어)
- `numpy`: 배열 연산 (히스토그램, 마스크 연산)
- `flask`: 웹 인터페이스 (모니터링, 제어)
- `requests`: ESP32-CAM HTTP 통신

### ESP32-CAM 설정
- 해상도: 320x240 (QVGA) - 처리 속도 최적화
- 프레임레이트: 10fps
- 포맷: JPEG (품질: 12/63)

---

## 예상 결과

**성공 시나리오:**
1. 어두운 이미지 → CLAHE로 선명하게 개선
2. 흰색 원 노이즈 → 컨투어 필터로 95% 제거
3. 직선 구간 → 안정적인 CENTER 판단
4. 곡선 구간 → 부드러운 LEFT/RIGHT 조향
5. 90도 코너 → LookAhead로 정확한 방향 판단

**예상 정확도:**
- 직선 추적: 95% 이상
- 곡선 추적: 90% 이상  
- 90도 코너 판단: 85% 이상
- 노이즈 제거: 95% 이상

**처리 시간 (320x240 이미지 기준):**
- 전처리 (CLAHE): ~5ms
- ROI + HSV: ~3ms
- 컨투어 필터: ~10ms
- 히스토그램: ~2ms
- **총: ~20ms (50fps 가능)**

---

## 문서 버전

- **Version**: 2.0
- **최종 업데이트**: 2025-10-22
- **작성자**: AI Assistant
- **검토 대상**: ESP32-CAM 자율주행 프로젝트